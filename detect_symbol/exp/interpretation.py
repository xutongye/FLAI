
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/interpretation.ipynb

#================================================
from exp import nb_anchors_loss_metrics


#================================================
import torch


#================================================
from torch import tensor


#================================================
from matplotlib import pyplot as plt


#================================================
from matplotlib import patches,patheffects


#================================================
from IPython.core import debugger as idb


#================================================
from math import ceil


#================================================
def process_netout(txys,thws,cats,confs,gaf):
    ts = torch.cat([txys,thws],dim=-1)
    boxs = gaf.t2b(ts,range(ts.shape[-2]))

    confs = torch.sigmoid(confs).squeeze(-1)
    prbs,cats = torch.softmax(cats,dim=-1).max(dim=-1)
#     cats = cats + 1

    return boxs,confs,cats,prbs


#================================================
def nms(boxes, cats, confs, ov_thres=0.2, despiteCat=True):
    '''
    despiteCat: despite category, 若=False，对相同类别做nms抑制；若=True，忽略类别，全局做nms
    '''
    keep = torch.zeros(confs.numel())
    count = 0

    if confs.numel()==0:
        # 如果无候选，返回
        return keep, count

    # 按 conf 从大至小排序
    idxs = confs.sort(0,descending=True)[1]

    while idxs.numel() >= 1:
        # 获取当前最置信的bbox
        idx_mc = idxs[0] # mc: most confident
        box_mc = boxes[idx_mc]
        cat_mc = cats[idx_mc]
        keep[count] = idx_mc
        count += 1

        # 除最置信之外的剩余bbox
        idxs = idxs[1:]
        if idxs.numel()==0: break
        boxes_r = boxes[idxs] # r: remain
        cats_r = cats[idxs]

        # 计算剩余与最大的IoU
        IoU = nb_anchors_loss_metrics.iou(box_mc.reshape(-1,4),boxes_r.reshape(-1,4)).squeeze()

        # 选择保留
        if despiteCat:
            # 若不考虑类别，则保留 IoU<=overlap 的
            idxs = idxs[IoU<=ov_thres]
        else:
            # 若考虑类别，则保留 IoU<=overlap 或 类别不同 的
            idxs = idxs[(IoU<=ov_thres) | (cats_r!=cat_mc)]

    return keep, count


#================================================
def netouts2preds(batchOut,gaf,composeConfPrb=True,filt_thres=0.9,ov_thres=0.2,despiteCat=True):
    '''
    处理一个batch
    '''
    batch_boxs = []
    batch_confs = []
    batch_cats = []
    batch_prbs = []
    batch_f1s = []

    for txys,confs,cats,thws in zip(batchOut[0].detach(),batchOut[1].detach(),batchOut[2].detach(),batchOut[3].detach()):
        boxs,confs,cats,prbs = process_netout(txys,thws,cats,confs,gaf)

        f1s = 2*confs*prbs/(confs+prbs)
        if composeConfPrb:
            filt = torch.where(f1s>filt_thres)
        else:
            filt = torch.where(confs>filt_thres)

        boxs = boxs[filt]
        confs = confs[filt]
        cats = cats[filt]
        prbs = prbs[filt]
        f1s = f1s[filt]

        if composeConfPrb:
            keep,cnt = nms(boxs, cats, f1s, ov_thres=ov_thres, despiteCat=True)
        else:
            keep,cnt = nms(boxs, cats, confs, ov_thres=ov_thres, despiteCat=True)

        keep = keep[:cnt].long()

        boxs = boxs[keep]
        confs = confs[keep]
        cats = cats[keep]
        prbs = prbs[keep]
        f1s = f1s[keep]

        batch_boxs += [boxs]
        batch_confs += [confs]
        batch_cats += [cats]
        batch_prbs += [prbs]
        batch_f1s += [f1s]

    return batch_boxs, batch_confs, batch_cats, batch_prbs, batch_f1s


#================================================
def draw_outline(o, lw):
    o.set_path_effects([patheffects.Stroke(
        linewidth=lw, foreground='red'), patheffects.Normal()])


#================================================
def draw_text(ax, xy, txt, sz=14, color='white'):
    text = ax.text(*xy, txt,
        verticalalignment='top', color=color, fontsize=sz, weight='bold')
    draw_outline(text, 4)


#================================================
def draw_rect(ax, b, color='red',lw=2):
    x = b[1]
    y = b[0]
    w = b[3]-b[1]
    h = b[2]-b[0]

    patch = ax.add_patch(patches.Rectangle((x,y), w, h, fill=False, edgecolor=color, lw=lw))
    draw_outline(patch, lw=lw)


#================================================
def show_batch_pred(batch_x,
                    batch_boxs,
                    batch_cats,
                    batch_scores,
                    classes):
    '''
    输入原图，nms处理后的模型预测，绘制这些预测。以batch为单位绘制。
    ------------------------------
    参数：
    -- batch_x：一个batch的图片，像素值应在[0,1]或[0,255]范围内，图片 shape 应为 height * width * channel
    -- batch_boxs：目标框，每个框表示为（左上角x，左上角y，右下角x，右下角y）
    -- batch_cats：类别，每个类别以整数表示，该整数作为classes的索引
    -- batch_scores：目标得分，可以是confidence，也可以是f1得分(=conf*prb/(conf+prb))，你传入什么就打印什么
    -- classes：一个list，元素为字符串，是各类别的名称，其顺序应与batch_cats对应
    '''
    bs = len(batch_cats)
    rows = ceil(bs/2)

    _,axs = plt.subplots(rows,2,figsize=(20,10*rows))
    axs = axs.flatten()

    for i in range(bs):
        ax = axs[i]

        x = batch_x[i]
        x = x.permute(1,2,0)
        ax.imshow(x)

        h,w = x.shape[:2]
        img_s = tensor([h,w,h,w]).to(batch_boxs[0].device)

        boxs = batch_boxs[i]
        cats = batch_cats[i]
        scores = batch_scores[i]

        for j in range(len(cats)):
            box = boxs[j]*img_s
            draw_rect(ax,box,lw=1)

            cat = cats[j]
            clas = classes[cat][:3]
            score = scores[j]
            info = '{}_{:.2f}'.format(clas,score*100)
            draw_text(ax,box[[3,0]],info,sz=8)
